
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Intro to Containers</title>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <link rel="import" href="../../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style>
    body {
      font-family: "Roboto",sans-serif;
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Intro to Containers"
                  environment="web"
                  feedback-link="https://docs.google.com/document/d/1s6ElhALBm2fISBV_eWklqaG2Ayni8reIcquqwtjJdkU/edit?usp=sharing">
    
      <google-codelab-step label="Overview" duration="1">
        <p><img style="max-width: 624.00px" src="img/53995527f6a19657.png"></p>
<p>By the end of this cloud lab you should have a solid grasp on the tradeoffs and differences between Containers and VMs.</p>
<h2 class="checklist">What you&#39;ll learn</h2>
<ul class="checklist">
<li>How to write a Dockerfile</li>
<li>How to build a container</li>
<li>How to run a container</li>
<li>How to use the GCP Container Registry Service</li>
<li>How Containers differ from Virtual machines</li>
</ul>
<h2>Prerequisites</h2>
<ul>
<li>Google Cloud Platform Account and a Project with Billing</li>
<li>Basic Linux Experience</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup" duration="1">
        <h3>Create a Project</h3>
<p>To make cleanup easier, let&#39;s create a new google cloud project.</p>
<ul>
<li>Navigate to <a href="https://console.cloud.google.com/" target="_blank">https://console.cloud.google.com</a>.</li>
<li>Click on the project selector dropdown</li>
<li>Select Create Project</li>
<li>Give it memorable name like, intro-to-containers</li>
</ul>

<h3>Launch CloudShell</h3>
<p>To make cleanup easier, let&#39;s create a new google cloud project.</p>
<ul>
<li>Navigate to <a href="https://console.cloud.google.com" target="_blank">https://console.cloud.google.com</a>. </li>
<li>Click on the project selector dropdown</li>
<li>Select Create Project</li>
<li>Give it memorable name like, intro-to-containers</li>
</ul>
<p>Now let&#39;s open the cloud shell. The cloud shell icon is at the top right:</p>
<p><img style="max-width: 624.00px" src="https://lh6.googleusercontent.com/tCXeQm-SR_AUtK-eFjaS_OQJh-W3_kYnYDCpauyfEZafoKKjEPyyIiduE_or21TmZLjm3byTYecu95Fa4_IVC9bhZy46u_w7ehrxlCDKdtHObXcBQL68Nt4KhLcunksVuV_euc_d"></p>
<p>A cloud shell session will open inside a new frame at the bottom of your browser.</p>
<p><img style="max-width: 624.00px" src="https://lh3.googleusercontent.com/rTl9b-QmntDngKMp90is2wP-WzFe2eYLgQSZCXQxAqoSAOxjelw_0bGsdR49RSUiLw19akKbjf2yyUNVXP_ra4z_A_BJ5gBPYqPPU07crIgU7LalhBLn6SRjsrg1GOrXpqMsqfbP"></p>

<p><br>Docker comes pre installed in cloud shell. If you ever want to see what version of docker is currently installed simply run the following command::</p>
<pre>$ docker --version</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Compare &amp; Contrast Containers with VMs" duration="2">
        <p>Containers do not contain the base operating system, just the OS&#39;s libraries. Making a container much more lightweight compared to a VM. Running a container use less disk space and less CPU cycles compared to a VM while still isolating the application. For example the Alpine linux container is only 5MB in size.</p>
<p><img style="max-width: 624.00px" src="img/532bdf8ab8c78067.png"></p>
<p>Containers can easily be based off of other containers.  In this learning we will build a container based off the node:7.2.0 container image. </p>
<p>Tools such-as docker and kubernetes give a good development to production story. Containers are faster and easier to build, and kubernetes allows you to have an easy way to manage your production services.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Dockerfiles" duration="5">
        <p>Dockerfiles include all the commands on how to build your container.  The Dockerfile will tell Docker how to download dependencies, and build your application. </p>
<p>Let&#39;s dissect an example dockerfile:</p>
<h3>Dockerfile</h3>
<pre><code>FROM ubuntu:latest

RUN apt-get install openjdk-8-jre

COPY server.jar /server.jar

ENV PORT=8080

CMD java -jar /server.jar

EXPOSE 8080</code></pre>
<h3>FROM ubuntu:latest</h3>
<p>This informs docker that the created image will be based upon the latest ubuntu LTS distribution. The ubuntu docker image will include all the default Ubuntu binaries such-as <code>cp</code>, <code>ls</code>, <code>cat</code>, and <code>apt</code>. Just like a VM you have a freedom to choose the underlying installed binaries.  However the specific linux kernel running is specified by the host running the docker container.</p>
<p>Many programming languages keep their own base image repository. For example here are some base images for some popular programming languages. These images have the specified runtime pre-installed. Most allow you to specify latest to pull the latest version of the given runtime.</p>
<ul>
<li><a href="https://hub.docker.com/_/node" target="_blank">Nodejs</a>:  <code>FROM node:4.4</code></li>
<li><a href="https://hub.docker.com/_/golang/" target="_blank">Golang</a>: <code>FROM golang:1.6</code></li>
<li><a href="https://hub.docker.com/_/java/" target="_blank">Java</a>: <code>FROM java:openjdk-8</code></li>
<li><a href="https://hub.docker.com/_/php/" target="_blank">PHP</a>: <code>FROM php:7.0-apache</code></li>
<li><a href="https://hub.docker.com/_/python/" target="_blank">Python</a>: <code>FROM python:3.5.2</code></li>
</ul>
<h3>RUN apt-get install <code>openjdk-8-jre</code></h3>
<p>The RUN instruction allows you to specify commands to be executed when building the image.  You can have as many RUN commands as your heart desires, and they will be executed sequentially.</p>
<h3>COPY server.jar /server.jar</h3>
<p>The COPY instruction allows you to specify files to be copied when building the image. COPY is basically like a <code>cp -R</code> except it&#39;ll copy from your local machine to the docker image. So in this specific case we are copying our local <code>./server.jar</code> to the docker image filesystem at <code>/server.jar</code>.</p>
<h3>ENV PORT=8080</h3>
<p>The ENV instruction specifies custom environment variables to be passed down to running applications. Think of this as a dynamic configuration for the program. For example cloud shell stores it&#39;s related project id in the environment variable <code>DEVSHELL_PROJECT_ID</code>. In your cloud type <code>printenv</code>, and you&#39;ll see a list of current environment variables. </p>
<h3>CMD java -jar /server.jar</h3>
<p>The CMD instruction specifies a <em>default</em> command to be executed when the container is run. Their can only be one CMD instruction. So in this case when our docker image is run a nodejs process running /server.js is started.</p>
<h3>Expose 8080</h3>
<p>The EXPOSE instruction informs the Docker runtime that there is some program listening to port 8080 in this container. This command does not make the exposed ports accessible to the host. To do so requires adding a command line argument when launching the docker container, such-as: </p>
<p><code>$ docker run -p &lt;external port&gt;:&lt;exposed port&gt; ...</code></p>


      </google-codelab-step>
    
      <google-codelab-step label="Building an Image" duration="7">
        <h3>server.js</h3>
<pre><code>&#34;use strict&#34;;

let http = require(&#39;http&#39;);

let server = http.createServer((request, response) =&gt; {
  console.log(&#39;Received request for URL: &#39; + request.url);
  response.writeHead(200, {&#34;Content-Type&#34;: &#34;text/plain&#34;});
  response.end(&#34;Hello World\n&#34;);
});

server.listen(process.env.PORT);</code></pre>
<p>Copy and paste this file into your cloud shell:</p>
<ul>
<li>Copy the entire code snippet above (highlight, then <code>ctrl+c</code>)</li>
<li>In your cloud shell run the command: <code>vim server.js</code></li>
<li>Click the <code>a</code> key, then press <code>ctrl-v</code>.</li>
<li>Now click your <code>esc</code> key, then type <code>wq</code> followed by <code>enter</code>.</li>
</ul>
<p>This application will respond with <code>Hello World!</code> to all incoming http requests on port declared through the environment variable <code>PORT</code>.</p>
<p>Feel to test this nodejs application by running it on the cloud shell.</p>
<pre>$ PORT=8000 node server.js &amp;
$ curl localhost:8000
Received request for URL: /
Hello World</pre>
<p>Now let&#39;s kill the nodejs application through the killall command:</p>
<pre>$ killall node
[1]+  Terminated              PORT=8000 node server.js</pre>
<h3>Dockerfile</h3>
<pre><code>FROM node:7.2.0

COPY server.js /server.js

ENV PORT=8080

CMD node /server.js

EXPOSE 8080</code></pre>
<p>Copy and paste this file into your cloud shell using the exact same flow as before.</p>
<ul>
<li>Copy the entire code snippet above (highlight, then <code>ctrl+c</code>)</li>
<li>In your cloud shell run the command: <code>vim Dockerfile</code></li>
<li>Click the <code>a</code> key, then press <code>ctrl-v</code>.</li>
<li>Now click your <code>esc</code> key, then type <code>wq</code> followed by <code>enter</code>.</li>
</ul>
<p>Since we are using the nodejs runtime we&#39;ll use a pre-packaged image for nodejs applications.</p>
<h3>Build the imCreating a Project<br><br>To make cleanup easier, let&#39;s create a new google cloud project.<br><br>Navigate to https://console.cloud.google.com.<br>Click on the project selector dropdown<br>Select Create Project<br>Give it memorable name like, intro-to-containers<br>age</h3>
<p>Copy both the server.js and Dockerfile into a directory in your cloud shell.</p>
<p>For this step let&#39;s tag the image with the text `hello-node`.</p>
<pre>$ docker build -t hello-world-node:v1 .</pre>
<p>For more information about our recently built container you can run:</p>
<pre>$ docker images hello-world-node</pre>
<p>If you had a new release for the docker container, simply update the version number from v1 to say v2-alpha.</p>
<pre>$ docker build -t hello-world-node:v2-alpha .</pre>
<p>You&#39;ll notice that when you list your images you&#39;ll see both v1 and v2 for repository hello-world-node.</p>
<pre>$ docker images hello-world-node

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world-node    latest              3006039b4210        3 minutes ago       655.5 MB
hello-world-node    v1                  3006039b4210        3 minutes ago       655.5 MB
hello-world-node    v2-alpha            3006039b4210        3 minutes ago       655.5 MB
</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Running an Image" duration="7">
        <aside class="warning"><p><strong>Warning:  </strong><code>docker run</code> by default does not run as a background daemon. You need to specify the --detach / -d flag to run the container in the background.</p>
</aside>
<aside class="special"><p><strong>Best Practices: </strong></p>
<p>If you want logs you&#39;ll want to specify the -i and -t flags to <code>docker run</code>.</p>
<ul>
<li><code>-t</code> gives the running container a pseudo tty.</li>
<li><code>-i</code> keeps stdin open even if the application is running in the background</li>
</ul>
</aside>
<p>In our dockerfile we exposed the port 8080 which the nodejs server is listening to. When we startup the image we have to map a port on the host which will map to our exposed docker port.</p>
<p>The following command will startup our hello-world-node:v1 image, run it in the background, keep a psudo terminal active, and route traffic from our host&#39;s port 8081 to the docker container&#39;s port 8080</p>
<pre>$ docker run -i -t -d -p 8081:8080 hello-world-node:v1</pre>
<p>Let&#39;s test our hello world service now and issue an HTTP GET request.</p>
<pre>$ curl -X GET &#34;localhost:8081&#34;
Hello World</pre>
<p>You&#39;ll notice that if you try run <code>curl localhost:8080</code> that an error will appear. This is due to the fact that you need to map ports from the docker host computer to the docker container. In this example we&#39;ve mapped traffic from the docker host port 8081 to the container&#39;s port 8080.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Viewing Active Containers" duration="7">
        <p>In true unix fashion docker has a ps sub command. This command will dump all running docker containers and some of their metadata.</p>
<pre>$ docker ps 
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
490c7c793dc5        hello-world-node:v1   &#34;/bin/sh -c &#39;node /se&#34;   7 minutes ago       Up 7 minutes        0.0.0.0:8081-&gt;8080/tcp   elated_allen</pre>
<p>For some fun go and spawn a bunch of instances of our hello-world-node:v2-alpha image.</p>
<pre>$ docker run -i -t -d -p 8082:8080 hello-world-node:v2-alpha
$ docker run -i -t -d -p 8083:8080 hello-world-node:v2-alpha
$ docker run -i -t -d -p 8084:8080 hello-world-node:v2-alpha</pre>
<p>Now when you run docker ps you&#39;ll find a bunch of containers. We can filter this list down by image name, for example to only view the running instances running the hello-world-node:v1 image you can issue the following:</p>
<pre>$ docker ps --filter=image=hello-world-node:v1
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
490c7c793dc5        hello-world-node:v1   &#34;/bin/sh -c &#39;node /se&#34;   7 minutes ago       Up 7 minutes        0.0.0.0:8081-&gt;8080/tcp   elated_allen</pre>
<h3>Getting a container&#39;s stdout</h3>
<p>When viewing a container&#39;s logs we have to reference the container&#39;s id.</p>
<p>Let&#39;s get one from a running <code>hello-world-node:v1</code> service:</p>
<pre>$ docker ps --filter=image=hello-world-node:v1 -n=1 -l --format=&#34;{{.ID}}&#34;
490c7c793dc5</pre>
<p>To print out the logs of container <code>490c7c793dc5</code> we issue:</p>
<pre>$ docker logs 490c7c793dc5</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Google Container Registry" duration="3">
        <table>
<tr><td colspan="1" rowspan="1"><p>Google Container Registry (GCR) stores Docker container images on GCP for fast, scalable retrieval and deployment.  You are only billed for storage and internet egress costs.</p>
<p>GCR has Access Control List (ACL) support to protect who can access your docker images. By default only members of your GCP project can access a GCR docker image.</p>
</td><td colspan="1" rowspan="1"><p><img style="max-width: 222.50px" src="img/dcc7501b23f5f562.png"></p>
</td></tr>
</table>
<h3>Tag Naming Scheme</h3>
<p>The GCR service requires uploaded images to have a image tag which adheres to the following format: </p>
<p><code>&lt;host&gt;/&lt;project id&gt;/&lt;image name&gt;:&lt;version name&gt;</code></p>
<p><strong>The following hosts are offered:</strong></p>
<ul>
<li>us.gcr.io hosts your images in the United States.</li>
<li>eu.gcr.io hosts your images in the European Union.</li>
<li>asia.gcr.io hosts your images in Asia.</li>
<li>gcr.io without a prefix hosts your images in the United States, but this behavior may change in a future release. To home your data in a single specific location, we recommend specifying one of the localized hostnames. Note that gcr.io and us.gcr.io are not interchangeable in your commands.</li>
<li>b.gcr.io can be used to push to <a href="https://cloud.google.com/container-registry/docs/using-with-google-cloud-platform#using_an_existing_google_cloud_storage_bucket" target="_blank">existing Google Storage buckets</a>.</li>
</ul>
<h3>Tagging an Image</h3>
<p>Given the following information, this is how you&#39;d tag your image for GCR. For your own testing please substitute <code>my-awesome-project</code> with your own gcp project id.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Host</p>
</td><td colspan="1" rowspan="1"><p>Project Id</p>
</td><td colspan="1" rowspan="1"><p>Image Name</p>
</td><td colspan="1" rowspan="1"><p>Version</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>us.gcr.io</p>
</td><td colspan="1" rowspan="1"><p>my-awesome-project</p>
</td><td colspan="1" rowspan="1"><p>hello-world-node</p>
</td><td colspan="1" rowspan="1"><p>v1</p>
</td></tr>
</table>
<p>This tag can be added at build</p>
<pre>$ docker build -t us.gcr.io/my-awesome-project/hello-world-node:v1 .</pre>
<p>Or it can be added to an existing image as well</p>
<pre>$ docker tag hello-world-node:v1 us.gcr.io/my-awesome-project/hello-world-node:v1</pre>
<h3>Upload an image</h3>
<p>Above we tagged our image <code>us.gcr.io/my-awesome-project/hello-world-node</code> which where our image will be hosted on the GCR service.</p>
<p>To upload the image we simply use the <code>gcloud docker --push command</code>:</p>
<pre>$ gcloud docker --push us.gcr.io/my-awesome-project/hello-world-node:v1</pre>
<p>You can make images public or change the default ACLs through the <a href="https://cloud.google.com/container-registry/docs/access-control" target="_blank">gsutil</a> utility.</p>
<h3>Download an image</h3>
<p>Downloading is just like pushing an image. We simply substitute a --pull flag:</p>
<pre>$ gcloud docker pull -- us.gcr.io/my-awesome-project/hello-world-node:v1</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="0">
        <h2>Cleanup</h2>
<p>You are a container Expert now! </p>
<h3>Delete the Project</h3>
<p>To cleanup, we simply delete our project.</p>
<ul>
<li>In the navigation menu select IAM &amp; Admin</li>
<li>Then click on settings in the submenu</li>
<li>Click on the trashcan icon with the text &#34;Delete Project&#34;</li>
<li>Follow the prompts instructions</li>
</ul>

<h2 class="checklist">What we&#39;ve covered</h2>
<ul class="checklist">
<li>How to write a Dockerfile</li>
<li>How to build a container</li>
<li>How to run a container</li>
<li>How to use the GCP Container Registry Service</li>
<li>How Containers differ from Virtual machines</li>
</ul>
<p>Please spend a few seconds to give us some feedback to we can improve this learning.</p>
<google-codelab-survey survey-id="intro-to-containers-1">
<h4>How will you use this tutorial?</h4>
<paper-radio-group>
<paper-radio-button>Only read through it</paper-radio-button>
<paper-radio-button>Read it and complete the exercises</paper-radio-button>
</paper-radio-group>
</google-codelab-survey>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-88560603-1', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
